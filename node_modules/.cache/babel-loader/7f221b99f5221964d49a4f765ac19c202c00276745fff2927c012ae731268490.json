{"ast":null,"code":"var _jsxFileName = \"/Users/ericwang/Theseus/typing-racer/src/components/TypingGame.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport styled from 'styled-components';\nimport RaceTrack from './RaceTrack';\nimport Results from './Results';\nimport { easyTexts } from '../data/easyTexts';\nimport { mediumTexts } from '../data/mediumTexts';\nimport { hardTexts } from '../data/hardTexts';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GameContainer = styled.div`\n  background-color: white;\n  border-radius: 10px;\n  padding: 30px;\n  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);\n  margin-bottom: 30px;\n`;\n_c = GameContainer;\nconst TextContainer = styled.div`\n  font-family: 'Courier New', monospace;\n  font-size: 1.2rem;\n  line-height: 1.6;\n  margin-bottom: 25px;\n  padding: 20px;\n  border-radius: 8px;\n  background-color: #f9f9f9;\n  white-space: pre-wrap;\n  overflow-wrap: break-word;\n  height: 150px;\n  overflow-y: auto;\n  border: 2px solid #eee;\n  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);\n  position: relative;\n`;\n_c2 = TextContainer;\nconst HighlightedText = styled.span`\n  background-color: ${props => props.isCurrent ? 'rgba(255, 255, 153, 0.7)' : 'transparent'};\n  color: ${props => {\n  if (props.isCurrent) return '#333';\n  return props.isCorrect ? '#27ae60' : '#e74c3c';\n}};\n  text-decoration: ${props => !props.isCorrect && !props.isCurrent ? 'line-through' : 'none'};\n  transition: all 0.15s ease;\n  padding: 0 1px;\n  border-radius: 2px;\n  position: relative;\n  \n  ${props => props.isCurrent && `\n    box-shadow: 0 0 0 2px rgba(255, 255, 153, 0.5);\n    animation: pulse 1.5s infinite;\n    \n    @keyframes pulse {\n      0%, 100% {\n        box-shadow: 0 0 0 2px rgba(255, 255, 153, 0.5);\n      }\n      50% {\n        box-shadow: 0 0 0 4px rgba(255, 255, 153, 0.3);\n      }\n    }\n  `}\n`;\n_c3 = HighlightedText;\nconst UnusedText = styled.span`\n  color: #999;\n`;\n_c4 = UnusedText;\nconst InputArea = styled.textarea`\n  width: 100%;\n  padding: 20px;\n  font-family: 'Courier New', monospace;\n  font-size: 1.2rem;\n  border: 2px solid #ddd;\n  border-radius: 8px;\n  resize: none;\n  height: 120px;\n  margin-bottom: 25px;\n  transition: all 0.3s ease;\n  \n  &:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);\n  }\n`;\n_c5 = InputArea;\nconst StatContainer = styled.div`\n  display: flex;\n  justify-content: space-between;\n  margin-bottom: 25px;\n  padding: 15px;\n  background: linear-gradient(to right, rgba(52, 152, 219, 0.05), rgba(52, 152, 219, 0.1));\n  border-radius: 10px;\n  margin-bottom: 20px;\n  padding: 10px;\n  background-color: #f0f0f0;\n  border-radius: 5px;\n`;\n_c6 = StatContainer;\nconst Stat = styled.div`\n  text-align: center;\n`;\n_c7 = Stat;\nconst StatLabel = styled.div`\n  font-size: 0.9rem;\n  color: #555;\n  margin-bottom: 5px;\n`;\n_c8 = StatLabel;\nconst StatValue = styled.div`\n  font-size: 1.2rem;\n  font-weight: bold;\n  color: #333;\n`;\n_c9 = StatValue;\nconst ErrorMessage = styled.div`\n  background-color: #ffebee;\n  border: 1px solid #f44336;\n  color: #d32f2f;\n  padding: 15px;\n  border-radius: 8px;\n  margin-bottom: 20px;\n  font-size: 1rem;\n  box-shadow: 0 2px 8px rgba(244, 67, 54, 0.2);\n  display: flex;\n  align-items: center;\n  \n  &::before {\n    content: '⚠️';\n    margin-right: 10px;\n    font-size: 1.3rem;\n  }\n`;\n\n// Define target word counts for each difficulty level\n_c10 = ErrorMessage;\nconst TARGET_WORD_COUNTS = {\n  easy: 100,\n  medium: 150,\n  hard: 200\n};\n\n// Define time limits for each difficulty level (in seconds)\nconst TIME_LIMITS = {\n  easy: 180,\n  // 3 minutes\n  medium: 180,\n  // 3 minutes\n  hard: 120 // 2 minutes\n};\n\n// Select all text in the current difficulty level\nconst getAllTextsForDifficulty = difficulty => {\n  switch (difficulty) {\n    case 'easy':\n      return easyTexts.map(item => item.text);\n    case 'medium':\n      return mediumTexts.map(item => item.text);\n    case 'hard':\n      return hardTexts.map(item => item.text);\n    default:\n      return easyTexts.map(item => item.text);\n  }\n};\n\n// Count words in a text\nconst countWords = text => {\n  return text.trim().split(/\\s+/).length;\n};\n\n// Add persistent tracking of used texts across game sessions\nconst getUsedTextsFromStorage = () => {\n  try {\n    const storedUsedTexts = localStorage.getItem('typingRacer_usedTexts');\n    if (storedUsedTexts) {\n      return new Set(JSON.parse(storedUsedTexts));\n    }\n  } catch (error) {\n    console.error(\"Error loading used texts from storage:\", error);\n  }\n  return new Set();\n};\nconst saveUsedTextsToStorage = texts => {\n  try {\n    localStorage.setItem('typingRacer_usedTexts', JSON.stringify(Array.from(texts)));\n  } catch (error) {\n    console.error(\"Error saving used texts to storage:\", error);\n  }\n};\nconst TypingGame = ({\n  text: textProp,\n  difficulty,\n  onEndGame\n}) => {\n  _s();\n  // Complete text pool for current difficulty\n  const [textPool, setTextPool] = useState([]);\n  // Current text being typed\n  const [currentText, setCurrentText] = useState('');\n  // Full text the user needs to type (may include multiple text segments)\n  const [fullText, setFullText] = useState('');\n  // Total words typed across all texts\n  const [totalWordsTyped, setTotalWordsTyped] = useState(0);\n  // Target word count for current difficulty\n  const [targetWordCount, setTargetWordCount] = useState(TARGET_WORD_COUNTS[difficulty]);\n  // Time limit for current difficulty\n  const [timeLimit, setTimeLimit] = useState(TIME_LIMITS[difficulty]);\n  // Time remaining in seconds\n  const [timeLeft, setTimeLeft] = useState(TIME_LIMITS[difficulty]);\n  // Used texts to avoid repeating the same text\n  const [usedTexts, setUsedTexts] = useState(new Set());\n  // Store the most recently used text\n  const [lastUsedText, setLastUsedText] = useState('');\n  // Store ENTIRE initial text to prevent repetition\n  const [initialText, setInitialText] = useState('');\n  // Track all segments we've added to avoid repetition\n  const [allTextSegments, setAllTextSegments] = useState([]);\n  const [inputText, setInputText] = useState('');\n  const [startTime, setStartTime] = useState(null);\n  const [typingStarted, setTypingStarted] = useState(false);\n  const [gameOver, setGameOver] = useState(false);\n  const [correctChars, setCorrectChars] = useState(0);\n  const [incorrectChars, setIncorrectChars] = useState(0);\n  const [mistakesMade, setMistakesMade] = useState(0);\n  const [wordsTyped, setWordsTyped] = useState(0);\n  const [charsTyped, setCharsTyped] = useState(0);\n  const [wpm, setWpm] = useState(0);\n  const [accuracy, setAccuracy] = useState(100);\n  const [carPosition, setCarPosition] = useState(0);\n  const [previousBestWpm, setPreviousBestWpm] = useState(0);\n  const [previousBestPosition, setPreviousBestPosition] = useState(0);\n  const [error, setError] = useState(null);\n  const inputRef = useRef(null);\n  const textContainerRef = useRef(null);\n  const lastCorrectIndexRef = useRef(0);\n  const currentPosRef = useRef(0);\n\n  // Initialize text pool, target word count, and time limit\n  useEffect(() => {\n    try {\n      // Get all texts for the current difficulty\n      const allTexts = getAllTextsForDifficulty(difficulty);\n\n      // Make sure we have enough texts - duplicate and slightly modify if necessary\n      let extendedTextPool = [...allTexts];\n\n      // If we don't have at least 10 unique texts, create variations\n      if (allTexts.length < 10) {\n        // Add variations of existing texts by adding/removing some filler words\n        const fillerPhrases = [\"In other words, \", \"To put it simply, \", \"It's worth noting that \", \"Interestingly, \", \"Importantly, \"];\n        allTexts.forEach(text => {\n          const randomFiller = fillerPhrases[Math.floor(Math.random() * fillerPhrases.length)];\n          extendedTextPool.push(randomFiller + text);\n        });\n      }\n\n      // Shuffle the text pool to ensure random order\n      const shuffledTextPool = [...extendedTextPool];\n      for (let i = shuffledTextPool.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [shuffledTextPool[i], shuffledTextPool[j]] = [shuffledTextPool[j], shuffledTextPool[i]];\n      }\n\n      // Get previously used texts from localStorage to avoid repeats across sessions\n      const persistentUsedTexts = getUsedTextsFromStorage();\n\n      // Filter out already used texts from previous sessions\n      const filteredTextPool = shuffledTextPool.filter(poolText => {\n        // Skip if already used in a previous session\n        return !persistentUsedTexts.has(poolText);\n      });\n\n      // If we have no texts available after filtering, clear the persistent storage\n      // This ensures users don't run out of texts after playing many games\n      if (filteredTextPool.length === 0) {\n        console.log(\"All texts have been used in previous sessions, resetting history\");\n        localStorage.removeItem('typingRacer_usedTexts');\n        persistentUsedTexts.clear();\n      }\n\n      // Determine which pool to use\n      const availablePool = filteredTextPool.length > 0 ? filteredTextPool : shuffledTextPool;\n\n      // Select a completely random initial text from the available pool\n      // IMPORTANT: We are deliberately NOT using the text prop at all to avoid repetition\n      let selectedInitialText = '';\n      if (availablePool.length > 0) {\n        const randomIndex = Math.floor(Math.random() * availablePool.length);\n        selectedInitialText = availablePool[randomIndex];\n      } else {\n        // This should never happen, but as a last resort create a generic text\n        selectedInitialText = \"The quick brown fox jumps over the lazy dog. This is a simple sentence for typing practice.\";\n      }\n\n      // Update the persistent storage with our new text\n      persistentUsedTexts.add(selectedInitialText);\n      saveUsedTextsToStorage(persistentUsedTexts);\n\n      // Save the text pool without the one we're using, for future selections\n      const finalTextPool = shuffledTextPool.filter(t => {\n        // Exact match check\n        if (t === selectedInitialText) return false;\n\n        // Check if the text contains the initial text or vice versa\n        if (t.includes(selectedInitialText) || selectedInitialText.includes(t)) return false;\n        return true;\n      });\n      setTextPool(finalTextPool);\n      setLastUsedText(selectedInitialText);\n      setInitialText(selectedInitialText);\n      setAllTextSegments([selectedInitialText]);\n\n      // Target word count and time settings\n      setTargetWordCount(TARGET_WORD_COUNTS[difficulty]);\n      setTimeLimit(TIME_LIMITS[difficulty]);\n      setTimeLeft(TIME_LIMITS[difficulty]);\n\n      // Initialize the used texts set\n      const initialUsedTexts = new Set();\n      initialUsedTexts.add(selectedInitialText);\n      setUsedTexts(initialUsedTexts);\n\n      // Set the current text to our selected initial text\n      setCurrentText(selectedInitialText);\n      setFullText(selectedInitialText);\n      console.log(`Initialized with text pool of ${finalTextPool.length} texts`);\n      console.log(`Selected a fresh initial text: \"${selectedInitialText.substring(0, 30)}...\"`);\n      console.log(`Tracked ${initialUsedTexts.size} texts as used initially`);\n    } catch (error) {\n      console.error(\"Error initializing text pool:\", error);\n      setError(\"Error loading text content. Please try again.\");\n    }\n  }, [difficulty]);\n\n  // This useEffect ensures car position is reset when component is mounted\n  useEffect(() => {\n    // Reset car position and previous best position on component mount\n    setCarPosition(0);\n    setPreviousBestPosition(0);\n\n    // Clean up any existing game state\n    setInputText('');\n    setTypingStarted(false);\n    setStartTime(null);\n    setWpm(0);\n    setGameOver(false);\n    setCorrectChars(0);\n    setIncorrectChars(0);\n    setWordsTyped(0);\n    setCharsTyped(0);\n    setAccuracy(100);\n    setMistakesMade(0);\n    setTotalWordsTyped(0);\n    setTimeLeft(TIME_LIMITS[difficulty]);\n    lastCorrectIndexRef.current = 0;\n    currentPosRef.current = 0;\n  }, [difficulty]);\n\n  // Timer countdown\n  useEffect(() => {\n    if (typingStarted && timeLeft > 0 && !gameOver) {\n      const timer = setTimeout(() => {\n        setTimeLeft(prev => prev - 1);\n      }, 1000);\n      return () => clearTimeout(timer);\n    } else if (timeLeft === 0 && !gameOver) {\n      setGameOver(true);\n    }\n  }, [typingStarted, timeLeft, gameOver]);\n\n  // Auto-scroll text as user types\n  useEffect(() => {\n    if (textContainerRef.current && typingStarted) {\n      const container = textContainerRef.current;\n      const currentPos = inputText.length;\n\n      // Only scroll if the position has changed\n      if (currentPos !== currentPosRef.current) {\n        currentPosRef.current = currentPos;\n\n        // Find the current character element\n        const currentCharElement = container.querySelector(`[data-index=\"${currentPos}\"]`);\n        if (currentCharElement) {\n          // Calculate where to scroll to keep current character in view with some context\n          const containerHeight = container.clientHeight;\n          const scrollPos = currentCharElement.getBoundingClientRect().top - container.getBoundingClientRect().top - containerHeight / 2;\n\n          // Smooth scroll to new position\n          container.scrollTo({\n            top: container.scrollTop + scrollPos,\n            behavior: 'smooth'\n          });\n        }\n      }\n    }\n  }, [inputText, typingStarted]);\n\n  // Calculate typing speed\n  const calculateSpeed = useCallback(() => {\n    try {\n      if (!startTime) return 0;\n      const timeElapsed = (Date.now() - startTime) / 1000 / 60; // in minutes\n      const totalWords = totalWordsTyped + inputText.trim().split(/\\s+/).length;\n      return timeElapsed > 0 ? Math.round(totalWords / timeElapsed) : 0;\n    } catch (error) {\n      console.error(\"Error calculating typing speed:\", error);\n      setError(\"Error calculating typing speed. Please try again.\");\n      return 0;\n    }\n  }, [startTime, inputText, totalWordsTyped]);\n\n  // Calculate car position based on progress through the text\n  const calculateCarPosition = useCallback(() => {\n    try {\n      // If no input yet, ensure car is at start position\n      if (!typingStarted) {\n        return 0;\n      }\n\n      // Calculate words typed so far (completed texts + current progress)\n      const currentWordsTyped = totalWordsTyped + (inputText.trim().split(/\\s+/).length || 0);\n\n      // Calculate progress percentage based on total target words\n      const progressPercentage = currentWordsTyped / targetWordCount * 100;\n\n      // Ensure the position is between 0 and 100\n      return Math.min(Math.max(0, progressPercentage), 100);\n    } catch (error) {\n      console.error(\"Error calculating car position:\", error);\n      return 0; // Default position\n    }\n  }, [typingStarted, inputText, totalWordsTyped, targetWordCount]);\n\n  // Load previous best scores from localStorage based on difficulty\n  useEffect(() => {\n    try {\n      const storageKey = `typingRacer_bestWpm_${difficulty}`;\n      const savedBestWpm = localStorage.getItem(storageKey);\n      if (savedBestWpm) {\n        const bestWpm = parseInt(savedBestWpm, 10);\n        setPreviousBestWpm(bestWpm);\n      }\n    } catch (error) {\n      console.error(\"Error loading previous best score:\", error);\n      // Continue without previous best data\n    }\n  }, [difficulty]);\n\n  // Save best score to localStorage when game ends\n  useEffect(() => {\n    if (gameOver && wpm > 0) {\n      try {\n        const storageKey = `typingRacer_bestWpm_${difficulty}`;\n        const savedBestWpm = localStorage.getItem(storageKey);\n        if (!savedBestWpm || wpm > parseInt(savedBestWpm, 10)) {\n          localStorage.setItem(storageKey, wpm.toString());\n        }\n      } catch (error) {\n        console.error(\"Error saving best score:\", error);\n      }\n    }\n  }, [gameOver, wpm, difficulty]);\n\n  // Function to add more text when needed\n  const addMoreText = useCallback(() => {\n    // Check if we've already reached the target word count\n    const currentWordCount = fullText.split(/\\s+/).length;\n    if (currentWordCount >= targetWordCount) {\n      return false;\n    }\n\n    // Use our explicitly stored values for comparison\n    // This is much more reliable than trying to extract from fullText\n\n    // Get unused texts from the pool with enhanced similarity checking\n    const availableTexts = textPool.filter(potentialText => {\n      // Skip if it's already in the used texts set\n      if (usedTexts.has(potentialText)) return false;\n\n      // Skip if it's the same as the last used text\n      if (potentialText === lastUsedText) return false;\n\n      // CRITICAL: Skip if this text is our initial text \n      if (potentialText === initialText) return false;\n\n      // CRITICAL: Check against every segment we've used\n      for (const segment of allTextSegments) {\n        // Exact match check\n        if (potentialText === segment) return false;\n\n        // Substantial containment check (over half of the text)\n        if (potentialText.length > 20 && segment.length > 20) {\n          // We don't want texts that mostly contain each other\n          if (potentialText.includes(segment.substring(0, segment.length / 2)) || segment.includes(potentialText.substring(0, potentialText.length / 2))) {\n            return false;\n          }\n        }\n      }\n\n      // Skip if the first 20 characters match any used text\n      for (const usedText of Array.from(usedTexts)) {\n        // Check beginning similarity (first few words)\n        if (potentialText.length > 20 && usedText.length > 20) {\n          if (potentialText.substring(0, 20) === usedText.substring(0, 20)) {\n            return false;\n          }\n        }\n\n        // Check ending similarity (last few words)\n        if (potentialText.length > 15 && usedText.length > 15) {\n          if (potentialText.slice(-15) === usedText.slice(-15)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    });\n    console.log(`Found ${availableTexts.length} unused texts out of ${textPool.length} total`);\n    let newText = \"\";\n    if (availableTexts.length > 0) {\n      // Use a random unused text\n      const randomIndex = Math.floor(Math.random() * availableTexts.length);\n      newText = availableTexts[randomIndex];\n\n      // Debug check for repetition against initial text\n      if (newText === initialText) {\n        console.error(\"CRITICAL ERROR: Selected text is same as initial text!\");\n        // Force a different selection\n        const remainingTexts = availableTexts.filter(t => t !== newText);\n        if (remainingTexts.length > 0) {\n          newText = remainingTexts[Math.floor(Math.random() * remainingTexts.length)];\n        }\n      }\n    } else {\n      // If all texts have been used, create a completely new unique variation\n      console.log(\"All texts have been used, creating a variation\");\n\n      // Find a text that's not the initial text or recently used\n      const safeTexts = textPool.filter(t => t !== initialText && t !== lastUsedText);\n      const baseText = safeTexts.length > 0 ? safeTexts[Math.floor(Math.random() * safeTexts.length)] : textPool[Math.floor(Math.random() * textPool.length)];\n\n      // Create a substantial variation to ensure uniqueness\n      if (baseText) {\n        // Create a complete transformation of the text\n        const words = baseText.split(\" \");\n\n        // Add unique prefix that's very different\n        const prefixes = [\"In contrast, \", \"On the other hand, \", \"Alternatively, \", \"Meanwhile, \", \"Elsewhere, \"];\n        const randomPrefix = prefixes[Math.floor(Math.random() * prefixes.length)];\n\n        // Full transformation by reversing words\n        words.reverse();\n        newText = randomPrefix + words.join(\" \");\n\n        // Final safety check\n        if (newText === initialText || allTextSegments.includes(newText)) {\n          newText = \"An entirely different perspective: \" + words.slice(Math.floor(words.length / 2)).join(\" \") + \" compared to \" + words.slice(0, Math.floor(words.length / 2)).join(\" \");\n        }\n      } else {\n        // Absolute fallback\n        newText = \"The quick brown fox jumps over the lazy dog. This text is used as a fallback.\";\n      }\n    }\n\n    // Make sure we're not accidentally using the same text\n    if (newText === initialText) {\n      console.log(\"Extremely critical warning: Selected text is still the same as initial text\");\n      // Emergency text generation that's completely different\n      newText = \"Here is an emergency fallback text to prevent repetition. This was added to fix a critical issue with text selection.\";\n    }\n\n    // Update tracking state\n    setLastUsedText(newText);\n\n    // Add the new text to used texts\n    const newUsedTexts = new Set(usedTexts);\n    newUsedTexts.add(newText);\n    setUsedTexts(newUsedTexts);\n\n    // Track this segment too\n    setAllTextSegments(prev => [...prev, newText]);\n    console.log(`Selected new text: \"${newText.substring(0, 30)}...\"`);\n    console.log(`Initial text was: \"${initialText.substring(0, 30)}...\"`);\n\n    // Add space between texts instead of vertical bar\n    const updatedFullText = fullText + \" \" + newText;\n    setFullText(updatedFullText);\n\n    // Update the current text\n    const typed = inputText.length;\n    setCurrentText(updatedFullText.substring(typed));\n    return true;\n  }, [fullText, inputText, textPool, targetWordCount, usedTexts, lastUsedText, initialText, allTextSegments]);\n\n  // Update stats on text input\n  useEffect(() => {\n    try {\n      if (!typingStarted && inputText.length > 0) {\n        setTypingStarted(true);\n        setStartTime(Date.now());\n      }\n      if (typingStarted && !gameOver) {\n        // Calculate correct and incorrect characters\n        let correct = 0;\n        let incorrect = 0;\n        for (let i = 0; i < inputText.length; i++) {\n          if (i < fullText.length) {\n            if (inputText[i] === fullText[i]) {\n              correct++;\n            } else {\n              incorrect++;\n            }\n          }\n        }\n\n        // Only count a mistake if the current character is wrong\n        // Compare the current character with the previous state\n        if (inputText.length > 0 && inputText.length <= fullText.length && inputText.length > lastCorrectIndexRef.current) {\n          const currentPos = inputText.length - 1;\n          if (inputText[currentPos] !== fullText[currentPos]) {\n            setMistakesMade(prev => prev + 1);\n          }\n          lastCorrectIndexRef.current = inputText.length;\n        }\n        setCorrectChars(correct);\n        setIncorrectChars(incorrect);\n        setCharsTyped(inputText.length);\n        setWordsTyped(inputText.trim().split(/\\s+/).length);\n\n        // Calculate accuracy\n        const totalChars = correct + incorrect;\n        setAccuracy(totalChars > 0 ? Math.round(correct / totalChars * 100) : 100);\n\n        // Calculate WPM\n        const currentWpm = calculateSpeed();\n        setWpm(currentWpm);\n\n        // Update car position based on progress through text\n        setCarPosition(calculateCarPosition());\n\n        // Check if user has completed the current text\n        if (inputText.length >= fullText.length) {\n          // Add the words from this text to the total\n          const currentTextWordCount = fullText.trim().split(/\\s+/).length;\n          const newTotalWords = totalWordsTyped + currentTextWordCount;\n          setTotalWordsTyped(newTotalWords);\n\n          // Check if we've reached the target word count\n          if (newTotalWords >= targetWordCount) {\n            setGameOver(true);\n          } else {\n            // Try to add more text\n            const textAdded = addMoreText();\n\n            // If no more text could be added, end the game\n            if (!textAdded) {\n              setGameOver(true);\n            } else {\n              // Reset input to start typing the new text\n              setInputText('');\n              lastCorrectIndexRef.current = 0;\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error updating typing statistics:\", error);\n      setError(\"Error updating statistics. Game will continue, but results might be affected.\");\n    }\n  }, [inputText, fullText, typingStarted, gameOver, calculateSpeed, calculateCarPosition, addMoreText, totalWordsTyped, targetWordCount]);\n\n  // Auto-focus input field\n  useEffect(() => {\n    try {\n      if (inputRef.current) {\n        inputRef.current.focus();\n      }\n    } catch (error) {\n      console.error(\"Error focusing input field:\", error);\n    }\n  }, []);\n\n  // Calculate final score\n  const calculateScore = () => {\n    try {\n      // New scoring formula with focus on WPM and accuracy\n      // Target: ~5000 for decent typing (60 WPM, 95% accuracy)\n      // Target: ~8000 for excellent typing (100 WPM, 100% accuracy)\n\n      // Base score heavily influenced by WPM\n      const wpmFactor = wpm * 60;\n\n      // Accuracy modifier: scales from 0.5 at 80% to 1.2 at 100%\n      // Heavily penalizes low accuracy, rewards perfect accuracy\n      const accuracyModifier = Math.max(0.5, accuracy / 100 * 1.5 - 0.3);\n\n      // Mistakes penalty\n      const mistakesPenalty = Math.max(0, 1 - mistakesMade / 100 * 0.5);\n\n      // Words typed provides a small bonus\n      const wordsBonus = Math.sqrt(totalWordsTyped) * 20;\n\n      // Time bonus - more points for completing before time limit\n      const timeBonus = timeLeft > 0 ? Math.sqrt(timeLeft) * 10 : 0;\n\n      // Combine factors\n      const rawScore = (wpmFactor + wordsBonus + timeBonus) * accuracyModifier * mistakesPenalty;\n\n      // Difficulty modifier\n      const difficultyMultiplier = {\n        easy: 0.85,\n        medium: 1.0,\n        hard: 1.25\n      }[difficulty];\n\n      // Calculate final score\n      const finalScore = Math.round(rawScore * difficultyMultiplier);\n\n      // Cap at 10,000\n      return Math.min(finalScore, 10000);\n    } catch (error) {\n      console.error(\"Error calculating score:\", error);\n      return 0; // Default score\n    }\n  };\n\n  // Format time display\n  const formatTime = seconds => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;\n  };\n\n  // Handle input change\n  const handleInputChange = e => {\n    try {\n      if (!gameOver) {\n        // Get the new value\n        const newValue = e.target.value;\n\n        // Check if this might be a paste operation (sudden addition of multiple characters)\n        if (newValue.length > inputText.length + 1) {\n          // Only allow pasting if it exactly matches the expected next portion of text\n          const addedText = newValue.substring(inputText.length);\n          const expectedText = fullText.substring(inputText.length, newValue.length);\n          if (addedText !== expectedText) {\n            // Paste doesn't match expected text - ignore it\n            setError(\"Copy-pasting is not allowed. Please type the text manually.\");\n            return;\n          }\n        }\n        setInputText(newValue);\n      }\n    } catch (error) {\n      console.error(\"Error handling input change:\", error);\n      setError(\"Error processing your typing. Please try again.\");\n    }\n  };\n\n  // Prevent paste operations\n  const handlePaste = e => {\n    e.preventDefault();\n    setError(\"Copy-pasting is not allowed. Please type the text manually.\");\n  };\n\n  // Render text with highlighting\n  const renderText = () => {\n    try {\n      const elements = [];\n\n      // Show a window of 500 characters, centered on the current typing position\n      const windowSize = 500;\n      const currentPos = inputText.length;\n      const startPos = Math.max(0, currentPos - windowSize / 2);\n      const endPos = Math.min(fullText.length, startPos + windowSize);\n      for (let i = startPos; i < endPos; i++) {\n        const isCurrent = i === inputText.length;\n        const isTyped = i < inputText.length;\n        const isCorrect = isTyped && fullText[i] === inputText[i];\n        if (isTyped) {\n          elements.push(/*#__PURE__*/_jsxDEV(HighlightedText, {\n            isCorrect: isCorrect,\n            isCurrent: isCurrent,\n            \"data-index\": i,\n            children: fullText[i]\n          }, i, false, {\n            fileName: _jsxFileName,\n            lineNumber: 828,\n            columnNumber: 13\n          }, this));\n        } else if (isCurrent) {\n          elements.push(/*#__PURE__*/_jsxDEV(HighlightedText, {\n            isCorrect: true,\n            isCurrent: true,\n            \"data-index\": i,\n            children: fullText[i]\n          }, i, false, {\n            fileName: _jsxFileName,\n            lineNumber: 839,\n            columnNumber: 13\n          }, this));\n        } else {\n          elements.push(/*#__PURE__*/_jsxDEV(UnusedText, {\n            \"data-index\": i,\n            children: fullText[i]\n          }, i, false, {\n            fileName: _jsxFileName,\n            lineNumber: 850,\n            columnNumber: 13\n          }, this));\n        }\n      }\n      return /*#__PURE__*/_jsxDEV(TextContainer, {\n        ref: textContainerRef,\n        children: elements\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 861,\n        columnNumber: 9\n      }, this);\n    } catch (error) {\n      console.error(\"Error rendering text:\", error);\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        children: \"Error rendering text. Please restart the game.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 867,\n        columnNumber: 14\n      }, this);\n    }\n  };\n  const TimeDisplay = styled.div`\n    background: ${props => timeLeft < 10 ? '#e74c3c' : '#2ecc71'};\n    color: white;\n    border-radius: 50%;\n    width: 60px;\n    height: 60px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 1.1rem;\n    font-weight: bold;\n    margin: 0 auto 20px;\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n    transition: all 0.3s ease;\n    animation: ${props => timeLeft < 10 ? 'pulse 1s infinite' : 'none'};\n    \n    @keyframes pulse {\n      0%, 100% {\n        transform: scale(1);\n      }\n      50% {\n        transform: scale(1.05);\n        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);\n      }\n    }\n  `;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: gameOver ? /*#__PURE__*/_jsxDEV(Results, {\n      wpm: wpm,\n      accuracy: accuracy,\n      correctChars: correctChars,\n      incorrectChars: incorrectChars,\n      wordsTyped: totalWordsTyped,\n      score: calculateScore(),\n      difficulty: difficulty,\n      onPlayAgain: onEndGame,\n      previousBestWpm: previousBestWpm,\n      mistakesMade: mistakesMade,\n      timeLeft: timeLeft,\n      timeLimit: timeLimit\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 901,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(GameContainer, {\n      children: [error && /*#__PURE__*/_jsxDEV(ErrorMessage, {\n        children: error\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 917,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(TimeDisplay, {\n        children: formatTime(timeLeft)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 919,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(RaceTrack, {\n        position: carPosition,\n        previousBestPosition: previousBestPosition,\n        progress: carPosition,\n        targetLength: targetWordCount\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 923,\n        columnNumber: 11\n      }, this), renderText(), /*#__PURE__*/_jsxDEV(InputArea, {\n        ref: inputRef,\n        value: inputText,\n        onChange: handleInputChange,\n        onPaste: handlePaste,\n        placeholder: \"Start typing here...\",\n        autoFocus: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 932,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(StatContainer, {\n        children: [/*#__PURE__*/_jsxDEV(Stat, {\n          children: [/*#__PURE__*/_jsxDEV(StatLabel, {\n            children: \"WPM\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 943,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(StatValue, {\n            children: wpm\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 944,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 942,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(Stat, {\n          children: [/*#__PURE__*/_jsxDEV(StatLabel, {\n            children: \"Accuracy\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 947,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(StatValue, {\n            children: [accuracy, \"%\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 948,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 946,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(Stat, {\n          children: [/*#__PURE__*/_jsxDEV(StatLabel, {\n            children: \"Progress\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 951,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(StatValue, {\n            children: [Math.round(carPosition), \"%\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 952,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 950,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(Stat, {\n          children: [/*#__PURE__*/_jsxDEV(StatLabel, {\n            children: \"Mistakes\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 955,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(StatValue, {\n            children: mistakesMade\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 956,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 954,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(Stat, {\n          children: [/*#__PURE__*/_jsxDEV(StatLabel, {\n            children: \"Best WPM\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 959,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(StatValue, {\n            children: previousBestWpm > 0 ? previousBestWpm : '-'\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 960,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 958,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 941,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 916,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 899,\n    columnNumber: 5\n  }, this);\n};\n_s(TypingGame, \"fzwu4qb1WbdVVA1y6qWBuTd/pqc=\");\n_c11 = TypingGame;\nexport default TypingGame;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11;\n$RefreshReg$(_c, \"GameContainer\");\n$RefreshReg$(_c2, \"TextContainer\");\n$RefreshReg$(_c3, \"HighlightedText\");\n$RefreshReg$(_c4, \"UnusedText\");\n$RefreshReg$(_c5, \"InputArea\");\n$RefreshReg$(_c6, \"StatContainer\");\n$RefreshReg$(_c7, \"Stat\");\n$RefreshReg$(_c8, \"StatLabel\");\n$RefreshReg$(_c9, \"StatValue\");\n$RefreshReg$(_c10, \"ErrorMessage\");\n$RefreshReg$(_c11, \"TypingGame\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","styled","RaceTrack","Results","easyTexts","mediumTexts","hardTexts","jsxDEV","_jsxDEV","GameContainer","div","_c","TextContainer","_c2","HighlightedText","span","props","isCurrent","isCorrect","_c3","UnusedText","_c4","InputArea","textarea","_c5","StatContainer","_c6","Stat","_c7","StatLabel","_c8","StatValue","_c9","ErrorMessage","_c10","TARGET_WORD_COUNTS","easy","medium","hard","TIME_LIMITS","getAllTextsForDifficulty","difficulty","map","item","text","countWords","trim","split","length","getUsedTextsFromStorage","storedUsedTexts","localStorage","getItem","Set","JSON","parse","error","console","saveUsedTextsToStorage","texts","setItem","stringify","Array","from","TypingGame","textProp","onEndGame","_s","textPool","setTextPool","currentText","setCurrentText","fullText","setFullText","totalWordsTyped","setTotalWordsTyped","targetWordCount","setTargetWordCount","timeLimit","setTimeLimit","timeLeft","setTimeLeft","usedTexts","setUsedTexts","lastUsedText","setLastUsedText","initialText","setInitialText","allTextSegments","setAllTextSegments","inputText","setInputText","startTime","setStartTime","typingStarted","setTypingStarted","gameOver","setGameOver","correctChars","setCorrectChars","incorrectChars","setIncorrectChars","mistakesMade","setMistakesMade","wordsTyped","setWordsTyped","charsTyped","setCharsTyped","wpm","setWpm","accuracy","setAccuracy","carPosition","setCarPosition","previousBestWpm","setPreviousBestWpm","previousBestPosition","setPreviousBestPosition","setError","inputRef","textContainerRef","lastCorrectIndexRef","currentPosRef","allTexts","extendedTextPool","fillerPhrases","forEach","randomFiller","Math","floor","random","push","shuffledTextPool","i","j","persistentUsedTexts","filteredTextPool","filter","poolText","has","log","removeItem","clear","availablePool","selectedInitialText","randomIndex","add","finalTextPool","t","includes","initialUsedTexts","substring","size","current","timer","setTimeout","prev","clearTimeout","container","currentPos","currentCharElement","querySelector","containerHeight","clientHeight","scrollPos","getBoundingClientRect","top","scrollTo","scrollTop","behavior","calculateSpeed","timeElapsed","Date","now","totalWords","round","calculateCarPosition","currentWordsTyped","progressPercentage","min","max","storageKey","savedBestWpm","bestWpm","parseInt","toString","addMoreText","currentWordCount","availableTexts","potentialText","segment","usedText","slice","newText","remainingTexts","safeTexts","baseText","words","prefixes","randomPrefix","reverse","join","newUsedTexts","updatedFullText","typed","correct","incorrect","totalChars","currentWpm","currentTextWordCount","newTotalWords","textAdded","focus","calculateScore","wpmFactor","accuracyModifier","mistakesPenalty","wordsBonus","sqrt","timeBonus","rawScore","difficultyMultiplier","finalScore","formatTime","seconds","mins","secs","handleInputChange","e","newValue","target","value","addedText","expectedText","handlePaste","preventDefault","renderText","elements","windowSize","startPos","endPos","isTyped","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","TimeDisplay","score","onPlayAgain","position","progress","targetLength","onChange","onPaste","placeholder","autoFocus","_c11","$RefreshReg$"],"sources":["/Users/ericwang/Theseus/typing-racer/src/components/TypingGame.tsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport styled from 'styled-components';\nimport RaceTrack from './RaceTrack';\nimport Results from './Results';\nimport { Difficulty } from '../App';\nimport { easyTexts } from '../data/easyTexts';\nimport { mediumTexts } from '../data/mediumTexts';\nimport { hardTexts } from '../data/hardTexts';\n\ninterface TypingGameProps {\n  text: string;\n  difficulty: Difficulty;\n  onEndGame: () => void;\n}\n\nconst GameContainer = styled.div`\n  background-color: white;\n  border-radius: 10px;\n  padding: 30px;\n  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);\n  margin-bottom: 30px;\n`;\n\nconst TextContainer = styled.div`\n  font-family: 'Courier New', monospace;\n  font-size: 1.2rem;\n  line-height: 1.6;\n  margin-bottom: 25px;\n  padding: 20px;\n  border-radius: 8px;\n  background-color: #f9f9f9;\n  white-space: pre-wrap;\n  overflow-wrap: break-word;\n  height: 150px;\n  overflow-y: auto;\n  border: 2px solid #eee;\n  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);\n  position: relative;\n`;\n\nconst HighlightedText = styled.span<{ isCorrect: boolean; isCurrent: boolean }>`\n  background-color: ${props => props.isCurrent ? 'rgba(255, 255, 153, 0.7)' : 'transparent'};\n  color: ${props => {\n    if (props.isCurrent) return '#333';\n    return props.isCorrect ? '#27ae60' : '#e74c3c';\n  }};\n  text-decoration: ${props => (!props.isCorrect && !props.isCurrent) ? 'line-through' : 'none'};\n  transition: all 0.15s ease;\n  padding: 0 1px;\n  border-radius: 2px;\n  position: relative;\n  \n  ${props => props.isCurrent && `\n    box-shadow: 0 0 0 2px rgba(255, 255, 153, 0.5);\n    animation: pulse 1.5s infinite;\n    \n    @keyframes pulse {\n      0%, 100% {\n        box-shadow: 0 0 0 2px rgba(255, 255, 153, 0.5);\n      }\n      50% {\n        box-shadow: 0 0 0 4px rgba(255, 255, 153, 0.3);\n      }\n    }\n  `}\n`;\n\nconst UnusedText = styled.span`\n  color: #999;\n`;\n\nconst InputArea = styled.textarea`\n  width: 100%;\n  padding: 20px;\n  font-family: 'Courier New', monospace;\n  font-size: 1.2rem;\n  border: 2px solid #ddd;\n  border-radius: 8px;\n  resize: none;\n  height: 120px;\n  margin-bottom: 25px;\n  transition: all 0.3s ease;\n  \n  &:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);\n  }\n`;\n\nconst StatContainer = styled.div`\n  display: flex;\n  justify-content: space-between;\n  margin-bottom: 25px;\n  padding: 15px;\n  background: linear-gradient(to right, rgba(52, 152, 219, 0.05), rgba(52, 152, 219, 0.1));\n  border-radius: 10px;\n  margin-bottom: 20px;\n  padding: 10px;\n  background-color: #f0f0f0;\n  border-radius: 5px;\n`;\n\nconst Stat = styled.div`\n  text-align: center;\n`;\n\nconst StatLabel = styled.div`\n  font-size: 0.9rem;\n  color: #555;\n  margin-bottom: 5px;\n`;\n\nconst StatValue = styled.div`\n  font-size: 1.2rem;\n  font-weight: bold;\n  color: #333;\n`;\n\nconst ErrorMessage = styled.div`\n  background-color: #ffebee;\n  border: 1px solid #f44336;\n  color: #d32f2f;\n  padding: 15px;\n  border-radius: 8px;\n  margin-bottom: 20px;\n  font-size: 1rem;\n  box-shadow: 0 2px 8px rgba(244, 67, 54, 0.2);\n  display: flex;\n  align-items: center;\n  \n  &::before {\n    content: '⚠️';\n    margin-right: 10px;\n    font-size: 1.3rem;\n  }\n`;\n\n// Define target word counts for each difficulty level\nconst TARGET_WORD_COUNTS = {\n  easy: 100,\n  medium: 150,\n  hard: 200\n};\n\n// Define time limits for each difficulty level (in seconds)\nconst TIME_LIMITS = {\n  easy: 180,  // 3 minutes\n  medium: 180, // 3 minutes\n  hard: 120    // 2 minutes\n};\n\n// Select all text in the current difficulty level\nconst getAllTextsForDifficulty = (difficulty: Difficulty): string[] => {\n  switch (difficulty) {\n    case 'easy':\n      return easyTexts.map(item => item.text);\n    case 'medium':\n      return mediumTexts.map(item => item.text);\n    case 'hard':\n      return hardTexts.map(item => item.text);\n    default:\n      return easyTexts.map(item => item.text);\n  }\n};\n\n// Count words in a text\nconst countWords = (text: string): number => {\n  return text.trim().split(/\\s+/).length;\n};\n\n// Add persistent tracking of used texts across game sessions\nconst getUsedTextsFromStorage = (): Set<string> => {\n  try {\n    const storedUsedTexts = localStorage.getItem('typingRacer_usedTexts');\n    if (storedUsedTexts) {\n      return new Set(JSON.parse(storedUsedTexts));\n    }\n  } catch (error) {\n    console.error(\"Error loading used texts from storage:\", error);\n  }\n  return new Set<string>();\n};\n\nconst saveUsedTextsToStorage = (texts: Set<string>) => {\n  try {\n    localStorage.setItem('typingRacer_usedTexts', JSON.stringify(Array.from(texts)));\n  } catch (error) {\n    console.error(\"Error saving used texts to storage:\", error);\n  }\n};\n\nconst TypingGame: React.FC<TypingGameProps> = ({\n  text: textProp,\n  difficulty,\n  onEndGame\n}) => {\n  // Complete text pool for current difficulty\n  const [textPool, setTextPool] = useState<string[]>([]);\n  // Current text being typed\n  const [currentText, setCurrentText] = useState<string>('');\n  // Full text the user needs to type (may include multiple text segments)\n  const [fullText, setFullText] = useState<string>('');\n  // Total words typed across all texts\n  const [totalWordsTyped, setTotalWordsTyped] = useState<number>(0);\n  // Target word count for current difficulty\n  const [targetWordCount, setTargetWordCount] = useState<number>(TARGET_WORD_COUNTS[difficulty]);\n  // Time limit for current difficulty\n  const [timeLimit, setTimeLimit] = useState<number>(TIME_LIMITS[difficulty]);\n  // Time remaining in seconds\n  const [timeLeft, setTimeLeft] = useState<number>(TIME_LIMITS[difficulty]);\n  // Used texts to avoid repeating the same text\n  const [usedTexts, setUsedTexts] = useState<Set<string>>(new Set());\n  // Store the most recently used text\n  const [lastUsedText, setLastUsedText] = useState<string>('');\n  // Store ENTIRE initial text to prevent repetition\n  const [initialText, setInitialText] = useState<string>('');\n  // Track all segments we've added to avoid repetition\n  const [allTextSegments, setAllTextSegments] = useState<string[]>([]);\n  \n  const [inputText, setInputText] = useState<string>('');\n  const [startTime, setStartTime] = useState<number | null>(null);\n  const [typingStarted, setTypingStarted] = useState<boolean>(false);\n  const [gameOver, setGameOver] = useState<boolean>(false);\n  const [correctChars, setCorrectChars] = useState<number>(0);\n  const [incorrectChars, setIncorrectChars] = useState<number>(0);\n  const [mistakesMade, setMistakesMade] = useState<number>(0);\n  const [wordsTyped, setWordsTyped] = useState<number>(0);\n  const [charsTyped, setCharsTyped] = useState<number>(0);\n  const [wpm, setWpm] = useState<number>(0);\n  const [accuracy, setAccuracy] = useState<number>(100);\n  const [carPosition, setCarPosition] = useState<number>(0);\n  const [previousBestWpm, setPreviousBestWpm] = useState<number>(0);\n  const [previousBestPosition, setPreviousBestPosition] = useState<number>(0);\n  const [error, setError] = useState<string | null>(null);\n  const inputRef = useRef<HTMLTextAreaElement>(null);\n  const textContainerRef = useRef<HTMLDivElement>(null);\n  const lastCorrectIndexRef = useRef<number>(0);\n  const currentPosRef = useRef<number>(0);\n  \n  // Initialize text pool, target word count, and time limit\n  useEffect(() => {\n    try {\n      // Get all texts for the current difficulty\n      const allTexts = getAllTextsForDifficulty(difficulty);\n      \n      // Make sure we have enough texts - duplicate and slightly modify if necessary\n      let extendedTextPool = [...allTexts];\n      \n      // If we don't have at least 10 unique texts, create variations\n      if (allTexts.length < 10) {\n        // Add variations of existing texts by adding/removing some filler words\n        const fillerPhrases = [\n          \"In other words, \", \n          \"To put it simply, \", \n          \"It's worth noting that \", \n          \"Interestingly, \", \n          \"Importantly, \"\n        ];\n        \n        allTexts.forEach(text => {\n          const randomFiller = fillerPhrases[Math.floor(Math.random() * fillerPhrases.length)];\n          extendedTextPool.push(randomFiller + text);\n        });\n      }\n      \n      // Shuffle the text pool to ensure random order\n      const shuffledTextPool = [...extendedTextPool];\n      for (let i = shuffledTextPool.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [shuffledTextPool[i], shuffledTextPool[j]] = [shuffledTextPool[j], shuffledTextPool[i]];\n      }\n      \n      // Get previously used texts from localStorage to avoid repeats across sessions\n      const persistentUsedTexts = getUsedTextsFromStorage();\n      \n      // Filter out already used texts from previous sessions\n      const filteredTextPool = shuffledTextPool.filter(poolText => {\n        // Skip if already used in a previous session\n        return !persistentUsedTexts.has(poolText);\n      });\n      \n      // If we have no texts available after filtering, clear the persistent storage\n      // This ensures users don't run out of texts after playing many games\n      if (filteredTextPool.length === 0) {\n        console.log(\"All texts have been used in previous sessions, resetting history\");\n        localStorage.removeItem('typingRacer_usedTexts');\n        persistentUsedTexts.clear();\n      }\n      \n      // Determine which pool to use\n      const availablePool = filteredTextPool.length > 0 ? filteredTextPool : shuffledTextPool;\n      \n      // Select a completely random initial text from the available pool\n      // IMPORTANT: We are deliberately NOT using the text prop at all to avoid repetition\n      let selectedInitialText = '';\n      if (availablePool.length > 0) {\n        const randomIndex = Math.floor(Math.random() * availablePool.length);\n        selectedInitialText = availablePool[randomIndex];\n      } else {\n        // This should never happen, but as a last resort create a generic text\n        selectedInitialText = \"The quick brown fox jumps over the lazy dog. This is a simple sentence for typing practice.\";\n      }\n      \n      // Update the persistent storage with our new text\n      persistentUsedTexts.add(selectedInitialText);\n      saveUsedTextsToStorage(persistentUsedTexts);\n      \n      // Save the text pool without the one we're using, for future selections\n      const finalTextPool = shuffledTextPool.filter(t => {\n        // Exact match check\n        if (t === selectedInitialText) return false;\n        \n        // Check if the text contains the initial text or vice versa\n        if (t.includes(selectedInitialText) || selectedInitialText.includes(t)) return false;\n        \n        return true;\n      });\n      \n      setTextPool(finalTextPool);\n      setLastUsedText(selectedInitialText);\n      setInitialText(selectedInitialText);\n      setAllTextSegments([selectedInitialText]);\n      \n      // Target word count and time settings\n      setTargetWordCount(TARGET_WORD_COUNTS[difficulty]);\n      setTimeLimit(TIME_LIMITS[difficulty]);\n      setTimeLeft(TIME_LIMITS[difficulty]);\n      \n      // Initialize the used texts set\n      const initialUsedTexts = new Set<string>();\n      initialUsedTexts.add(selectedInitialText);\n      setUsedTexts(initialUsedTexts);\n      \n      // Set the current text to our selected initial text\n      setCurrentText(selectedInitialText);\n      setFullText(selectedInitialText);\n      \n      console.log(`Initialized with text pool of ${finalTextPool.length} texts`);\n      console.log(`Selected a fresh initial text: \"${selectedInitialText.substring(0, 30)}...\"`);\n      console.log(`Tracked ${initialUsedTexts.size} texts as used initially`);\n    } catch (error) {\n      console.error(\"Error initializing text pool:\", error);\n      setError(\"Error loading text content. Please try again.\");\n    }\n  }, [difficulty]);\n  \n  // This useEffect ensures car position is reset when component is mounted\n  useEffect(() => {\n    // Reset car position and previous best position on component mount\n    setCarPosition(0);\n    setPreviousBestPosition(0);\n    \n    // Clean up any existing game state\n    setInputText('');\n    setTypingStarted(false);\n    setStartTime(null);\n    setWpm(0);\n    setGameOver(false);\n    setCorrectChars(0);\n    setIncorrectChars(0);\n    setWordsTyped(0);\n    setCharsTyped(0);\n    setAccuracy(100);\n    setMistakesMade(0);\n    setTotalWordsTyped(0);\n    setTimeLeft(TIME_LIMITS[difficulty]);\n    lastCorrectIndexRef.current = 0;\n    currentPosRef.current = 0;\n  }, [difficulty]);\n\n  // Timer countdown\n  useEffect(() => {\n    if (typingStarted && timeLeft > 0 && !gameOver) {\n      const timer = setTimeout(() => {\n        setTimeLeft(prev => prev - 1);\n      }, 1000);\n      \n      return () => clearTimeout(timer);\n    } else if (timeLeft === 0 && !gameOver) {\n      setGameOver(true);\n    }\n  }, [typingStarted, timeLeft, gameOver]);\n\n  // Auto-scroll text as user types\n  useEffect(() => {\n    if (textContainerRef.current && typingStarted) {\n      const container = textContainerRef.current;\n      const currentPos = inputText.length;\n      \n      // Only scroll if the position has changed\n      if (currentPos !== currentPosRef.current) {\n        currentPosRef.current = currentPos;\n        \n        // Find the current character element\n        const currentCharElement = container.querySelector(`[data-index=\"${currentPos}\"]`);\n        \n        if (currentCharElement) {\n          // Calculate where to scroll to keep current character in view with some context\n          const containerHeight = container.clientHeight;\n          const scrollPos = currentCharElement.getBoundingClientRect().top - \n                           container.getBoundingClientRect().top - \n                           (containerHeight / 2);\n          \n          // Smooth scroll to new position\n          container.scrollTo({\n            top: container.scrollTop + scrollPos,\n            behavior: 'smooth'\n          });\n        }\n      }\n    }\n  }, [inputText, typingStarted]);\n\n  // Calculate typing speed\n  const calculateSpeed = useCallback(() => {\n    try {\n      if (!startTime) return 0;\n      \n      const timeElapsed = (Date.now() - startTime) / 1000 / 60; // in minutes\n      const totalWords = totalWordsTyped + inputText.trim().split(/\\s+/).length;\n      \n      return timeElapsed > 0 ? Math.round(totalWords / timeElapsed) : 0;\n    } catch (error) {\n      console.error(\"Error calculating typing speed:\", error);\n      setError(\"Error calculating typing speed. Please try again.\");\n      return 0;\n    }\n  }, [startTime, inputText, totalWordsTyped]);\n\n  // Calculate car position based on progress through the text\n  const calculateCarPosition = useCallback(() => {\n    try {\n      // If no input yet, ensure car is at start position\n      if (!typingStarted) {\n        return 0;\n      }\n      \n      // Calculate words typed so far (completed texts + current progress)\n      const currentWordsTyped = totalWordsTyped + (inputText.trim().split(/\\s+/).length || 0);\n      \n      // Calculate progress percentage based on total target words\n      const progressPercentage = (currentWordsTyped / targetWordCount) * 100;\n      \n      // Ensure the position is between 0 and 100\n      return Math.min(Math.max(0, progressPercentage), 100);\n    } catch (error) {\n      console.error(\"Error calculating car position:\", error);\n      return 0; // Default position\n    }\n  }, [typingStarted, inputText, totalWordsTyped, targetWordCount]);\n\n  // Load previous best scores from localStorage based on difficulty\n  useEffect(() => {\n    try {\n      const storageKey = `typingRacer_bestWpm_${difficulty}`;\n      const savedBestWpm = localStorage.getItem(storageKey);\n      \n      if (savedBestWpm) {\n        const bestWpm = parseInt(savedBestWpm, 10);\n        setPreviousBestWpm(bestWpm);\n      }\n    } catch (error) {\n      console.error(\"Error loading previous best score:\", error);\n      // Continue without previous best data\n    }\n  }, [difficulty]);\n\n  // Save best score to localStorage when game ends\n  useEffect(() => {\n    if (gameOver && wpm > 0) {\n      try {\n        const storageKey = `typingRacer_bestWpm_${difficulty}`;\n        const savedBestWpm = localStorage.getItem(storageKey);\n        \n        if (!savedBestWpm || wpm > parseInt(savedBestWpm, 10)) {\n          localStorage.setItem(storageKey, wpm.toString());\n        }\n      } catch (error) {\n        console.error(\"Error saving best score:\", error);\n      }\n    }\n  }, [gameOver, wpm, difficulty]);\n\n  // Function to add more text when needed\n  const addMoreText = useCallback(() => {\n    // Check if we've already reached the target word count\n    const currentWordCount = fullText.split(/\\s+/).length;\n    if (currentWordCount >= targetWordCount) {\n      return false;\n    }\n    \n    // Use our explicitly stored values for comparison\n    // This is much more reliable than trying to extract from fullText\n    \n    // Get unused texts from the pool with enhanced similarity checking\n    const availableTexts = textPool.filter(potentialText => {\n      // Skip if it's already in the used texts set\n      if (usedTexts.has(potentialText)) return false;\n      \n      // Skip if it's the same as the last used text\n      if (potentialText === lastUsedText) return false;\n      \n      // CRITICAL: Skip if this text is our initial text \n      if (potentialText === initialText) return false;\n      \n      // CRITICAL: Check against every segment we've used\n      for (const segment of allTextSegments) {\n        // Exact match check\n        if (potentialText === segment) return false;\n        \n        // Substantial containment check (over half of the text)\n        if (potentialText.length > 20 && segment.length > 20) {\n          // We don't want texts that mostly contain each other\n          if (potentialText.includes(segment.substring(0, segment.length / 2)) ||\n              segment.includes(potentialText.substring(0, potentialText.length / 2))) {\n            return false;\n          }\n        }\n      }\n      \n      // Skip if the first 20 characters match any used text\n      for (const usedText of Array.from(usedTexts)) {\n        // Check beginning similarity (first few words)\n        if (potentialText.length > 20 && usedText.length > 20) {\n          if (potentialText.substring(0, 20) === usedText.substring(0, 20)) {\n            return false;\n          }\n        }\n        \n        // Check ending similarity (last few words)\n        if (potentialText.length > 15 && usedText.length > 15) {\n          if (potentialText.slice(-15) === usedText.slice(-15)) {\n            return false;\n          }\n        }\n      }\n      \n      return true;\n    });\n    \n    console.log(`Found ${availableTexts.length} unused texts out of ${textPool.length} total`);\n    \n    let newText = \"\";\n    if (availableTexts.length > 0) {\n      // Use a random unused text\n      const randomIndex = Math.floor(Math.random() * availableTexts.length);\n      newText = availableTexts[randomIndex];\n      \n      // Debug check for repetition against initial text\n      if (newText === initialText) {\n        console.error(\"CRITICAL ERROR: Selected text is same as initial text!\");\n        // Force a different selection\n        const remainingTexts = availableTexts.filter(t => t !== newText);\n        if (remainingTexts.length > 0) {\n          newText = remainingTexts[Math.floor(Math.random() * remainingTexts.length)];\n        }\n      }\n    } else {\n      // If all texts have been used, create a completely new unique variation\n      console.log(\"All texts have been used, creating a variation\");\n      \n      // Find a text that's not the initial text or recently used\n      const safeTexts = textPool.filter(t => t !== initialText && t !== lastUsedText);\n      const baseText = safeTexts.length > 0 \n        ? safeTexts[Math.floor(Math.random() * safeTexts.length)]\n        : textPool[Math.floor(Math.random() * textPool.length)];\n      \n      // Create a substantial variation to ensure uniqueness\n      if (baseText) {\n        // Create a complete transformation of the text\n        const words = baseText.split(\" \");\n        \n        // Add unique prefix that's very different\n        const prefixes = [\n          \"In contrast, \", \n          \"On the other hand, \", \n          \"Alternatively, \",\n          \"Meanwhile, \",\n          \"Elsewhere, \"\n        ];\n        const randomPrefix = prefixes[Math.floor(Math.random() * prefixes.length)];\n        \n        // Full transformation by reversing words\n        words.reverse();\n        newText = randomPrefix + words.join(\" \");\n        \n        // Final safety check\n        if (newText === initialText || allTextSegments.includes(newText)) {\n          newText = \"An entirely different perspective: \" + \n            words.slice(Math.floor(words.length/2)).join(\" \") + \n            \" compared to \" + words.slice(0, Math.floor(words.length/2)).join(\" \");\n        }\n      } else {\n        // Absolute fallback\n        newText = \"The quick brown fox jumps over the lazy dog. This text is used as a fallback.\";\n      }\n    }\n    \n    // Make sure we're not accidentally using the same text\n    if (newText === initialText) {\n      console.log(\"Extremely critical warning: Selected text is still the same as initial text\");\n      // Emergency text generation that's completely different\n      newText = \"Here is an emergency fallback text to prevent repetition. This was added to fix a critical issue with text selection.\";\n    }\n    \n    // Update tracking state\n    setLastUsedText(newText);\n    \n    // Add the new text to used texts\n    const newUsedTexts = new Set(usedTexts);\n    newUsedTexts.add(newText);\n    setUsedTexts(newUsedTexts);\n    \n    // Track this segment too\n    setAllTextSegments(prev => [...prev, newText]);\n    \n    console.log(`Selected new text: \"${newText.substring(0, 30)}...\"`);\n    console.log(`Initial text was: \"${initialText.substring(0, 30)}...\"`);\n    \n    // Add space between texts instead of vertical bar\n    const updatedFullText = fullText + \" \" + newText;\n    setFullText(updatedFullText);\n    \n    // Update the current text\n    const typed = inputText.length;\n    setCurrentText(updatedFullText.substring(typed));\n    \n    return true;\n  }, [fullText, inputText, textPool, targetWordCount, usedTexts, lastUsedText, initialText, allTextSegments]);\n\n  // Update stats on text input\n  useEffect(() => {\n    try {\n      if (!typingStarted && inputText.length > 0) {\n        setTypingStarted(true);\n        setStartTime(Date.now());\n      }\n\n      if (typingStarted && !gameOver) {\n        // Calculate correct and incorrect characters\n        let correct = 0;\n        let incorrect = 0;\n        \n        for (let i = 0; i < inputText.length; i++) {\n          if (i < fullText.length) {\n            if (inputText[i] === fullText[i]) {\n              correct++;\n            } else {\n              incorrect++;\n            }\n          }\n        }\n        \n        // Only count a mistake if the current character is wrong\n        // Compare the current character with the previous state\n        if (inputText.length > 0 && \n            inputText.length <= fullText.length && \n            inputText.length > lastCorrectIndexRef.current) {\n          const currentPos = inputText.length - 1;\n          if (inputText[currentPos] !== fullText[currentPos]) {\n            setMistakesMade(prev => prev + 1);\n          }\n          lastCorrectIndexRef.current = inputText.length;\n        }\n        \n        setCorrectChars(correct);\n        setIncorrectChars(incorrect);\n        setCharsTyped(inputText.length);\n        setWordsTyped(inputText.trim().split(/\\s+/).length);\n        \n        // Calculate accuracy\n        const totalChars = correct + incorrect;\n        setAccuracy(totalChars > 0 ? Math.round((correct / totalChars) * 100) : 100);\n        \n        // Calculate WPM\n        const currentWpm = calculateSpeed();\n        setWpm(currentWpm);\n        \n        // Update car position based on progress through text\n        setCarPosition(calculateCarPosition());\n        \n        // Check if user has completed the current text\n        if (inputText.length >= fullText.length) {\n          // Add the words from this text to the total\n          const currentTextWordCount = fullText.trim().split(/\\s+/).length;\n          const newTotalWords = totalWordsTyped + currentTextWordCount;\n          setTotalWordsTyped(newTotalWords);\n          \n          // Check if we've reached the target word count\n          if (newTotalWords >= targetWordCount) {\n            setGameOver(true);\n          } else {\n            // Try to add more text\n            const textAdded = addMoreText();\n            \n            // If no more text could be added, end the game\n            if (!textAdded) {\n              setGameOver(true);\n            } else {\n              // Reset input to start typing the new text\n              setInputText('');\n              lastCorrectIndexRef.current = 0;\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error updating typing statistics:\", error);\n      setError(\"Error updating statistics. Game will continue, but results might be affected.\");\n    }\n  }, [inputText, fullText, typingStarted, gameOver, calculateSpeed, calculateCarPosition, addMoreText, totalWordsTyped, targetWordCount]);\n\n  // Auto-focus input field\n  useEffect(() => {\n    try {\n      if (inputRef.current) {\n        inputRef.current.focus();\n      }\n    } catch (error) {\n      console.error(\"Error focusing input field:\", error);\n    }\n  }, []);\n\n  // Calculate final score\n  const calculateScore = () => {\n    try {\n      // New scoring formula with focus on WPM and accuracy\n      // Target: ~5000 for decent typing (60 WPM, 95% accuracy)\n      // Target: ~8000 for excellent typing (100 WPM, 100% accuracy)\n      \n      // Base score heavily influenced by WPM\n      const wpmFactor = wpm * 60;\n      \n      // Accuracy modifier: scales from 0.5 at 80% to 1.2 at 100%\n      // Heavily penalizes low accuracy, rewards perfect accuracy\n      const accuracyModifier = Math.max(0.5, (accuracy / 100) * 1.5 - 0.3);\n      \n      // Mistakes penalty\n      const mistakesPenalty = Math.max(0, 1 - (mistakesMade / 100) * 0.5);\n      \n      // Words typed provides a small bonus\n      const wordsBonus = Math.sqrt(totalWordsTyped) * 20;\n      \n      // Time bonus - more points for completing before time limit\n      const timeBonus = timeLeft > 0 ? Math.sqrt(timeLeft) * 10 : 0;\n      \n      // Combine factors\n      const rawScore = (wpmFactor + wordsBonus + timeBonus) * accuracyModifier * mistakesPenalty;\n      \n      // Difficulty modifier\n      const difficultyMultiplier = {\n        easy: 0.85,\n        medium: 1.0,\n        hard: 1.25\n      }[difficulty];\n      \n      // Calculate final score\n      const finalScore = Math.round(rawScore * difficultyMultiplier);\n      \n      // Cap at 10,000\n      return Math.min(finalScore, 10000);\n    } catch (error) {\n      console.error(\"Error calculating score:\", error);\n      return 0; // Default score\n    }\n  };\n\n  // Format time display\n  const formatTime = (seconds: number): string => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;\n  };\n\n  // Handle input change\n  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    try {\n      if (!gameOver) {\n        // Get the new value\n        const newValue = e.target.value;\n        \n        // Check if this might be a paste operation (sudden addition of multiple characters)\n        if (newValue.length > inputText.length + 1) {\n          // Only allow pasting if it exactly matches the expected next portion of text\n          const addedText = newValue.substring(inputText.length);\n          const expectedText = fullText.substring(inputText.length, newValue.length);\n          \n          if (addedText !== expectedText) {\n            // Paste doesn't match expected text - ignore it\n            setError(\"Copy-pasting is not allowed. Please type the text manually.\");\n            return;\n          }\n        }\n        \n        setInputText(newValue);\n      }\n    } catch (error) {\n      console.error(\"Error handling input change:\", error);\n      setError(\"Error processing your typing. Please try again.\");\n    }\n  };\n\n  // Prevent paste operations\n  const handlePaste = (e: React.ClipboardEvent) => {\n    e.preventDefault();\n    setError(\"Copy-pasting is not allowed. Please type the text manually.\");\n  };\n\n  // Render text with highlighting\n  const renderText = () => {\n    try {\n      const elements = [];\n      \n      // Show a window of 500 characters, centered on the current typing position\n      const windowSize = 500;\n      const currentPos = inputText.length;\n      const startPos = Math.max(0, currentPos - windowSize / 2);\n      const endPos = Math.min(fullText.length, startPos + windowSize);\n      \n      for (let i = startPos; i < endPos; i++) {\n        const isCurrent = i === inputText.length;\n        const isTyped = i < inputText.length;\n        const isCorrect = isTyped && fullText[i] === inputText[i];\n        \n        if (isTyped) {\n          elements.push(\n            <HighlightedText \n              key={i} \n              isCorrect={isCorrect} \n              isCurrent={isCurrent}\n              data-index={i}\n            >\n              {fullText[i]}\n            </HighlightedText>\n          );\n        } else if (isCurrent) {\n          elements.push(\n            <HighlightedText \n              key={i} \n              isCorrect={true} \n              isCurrent={true}\n              data-index={i}\n            >\n              {fullText[i]}\n            </HighlightedText>\n          );\n        } else {\n          elements.push(\n            <UnusedText \n              key={i}\n              data-index={i}\n            >\n              {fullText[i]}\n            </UnusedText>\n          );\n        }\n      }\n      \n      return (\n        <TextContainer ref={textContainerRef}>\n          {elements}\n        </TextContainer>\n      );\n    } catch (error) {\n      console.error(\"Error rendering text:\", error);\n      return <div>Error rendering text. Please restart the game.</div>;\n    }\n  };\n\n  const TimeDisplay = styled.div`\n    background: ${props => timeLeft < 10 ? '#e74c3c' : '#2ecc71'};\n    color: white;\n    border-radius: 50%;\n    width: 60px;\n    height: 60px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 1.1rem;\n    font-weight: bold;\n    margin: 0 auto 20px;\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n    transition: all 0.3s ease;\n    animation: ${props => timeLeft < 10 ? 'pulse 1s infinite' : 'none'};\n    \n    @keyframes pulse {\n      0%, 100% {\n        transform: scale(1);\n      }\n      50% {\n        transform: scale(1.05);\n        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);\n      }\n    }\n  `;\n\n  return (\n    <div>\n      {gameOver ? (\n        <Results\n          wpm={wpm}\n          accuracy={accuracy}\n          correctChars={correctChars}\n          incorrectChars={incorrectChars}\n          wordsTyped={totalWordsTyped}\n          score={calculateScore()}\n          difficulty={difficulty}\n          onPlayAgain={onEndGame}\n          previousBestWpm={previousBestWpm}\n          mistakesMade={mistakesMade}\n          timeLeft={timeLeft}\n          timeLimit={timeLimit}\n        />\n      ) : (\n        <GameContainer>\n          {error && <ErrorMessage>{error}</ErrorMessage>}\n          \n          <TimeDisplay>\n            {formatTime(timeLeft)}\n          </TimeDisplay>\n          \n          <RaceTrack \n            position={carPosition} \n            previousBestPosition={previousBestPosition}\n            progress={carPosition}\n            targetLength={targetWordCount}\n          />\n          \n          {renderText()}\n          \n          <InputArea\n            ref={inputRef}\n            value={inputText}\n            onChange={handleInputChange}\n            onPaste={handlePaste}\n            placeholder=\"Start typing here...\"\n            autoFocus\n          />\n          \n          <StatContainer>\n            <Stat>\n              <StatLabel>WPM</StatLabel>\n              <StatValue>{wpm}</StatValue>\n            </Stat>\n            <Stat>\n              <StatLabel>Accuracy</StatLabel>\n              <StatValue>{accuracy}%</StatValue>\n            </Stat>\n            <Stat>\n              <StatLabel>Progress</StatLabel>\n              <StatValue>{Math.round(carPosition)}%</StatValue>\n            </Stat>\n            <Stat>\n              <StatLabel>Mistakes</StatLabel>\n              <StatValue>{mistakesMade}</StatValue>\n            </Stat>\n            <Stat>\n              <StatLabel>Best WPM</StatLabel>\n              <StatValue>{previousBestWpm > 0 ? previousBestWpm : '-'}</StatValue>\n            </Stat>\n          </StatContainer>\n        </GameContainer>\n      )}\n    </div>\n  );\n};\n\nexport default TypingGame; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}